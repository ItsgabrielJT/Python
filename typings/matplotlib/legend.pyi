"""
This type stub file was generated by pyright.
"""

from matplotlib import docstring
from matplotlib.artist import Artist, allow_rasterization
from matplotlib.offsetbox import DraggableOffsetBox

"""
The legend module defines the Legend class, which is responsible for
drawing legends associated with axes and/or figures.

.. important::

    It is unlikely that you would ever create a Legend instance manually.
    Most users would normally create a legend via the `~.Axes.legend`
    function. For more details on legends there is also a :doc:`legend guide
    </tutorials/intermediate/legend_guide>`.

The `Legend` class is a container of legend handles and legend texts.

The legend handler map specifies how to create legend handles from artists
(lines, patches, etc.) in the axes or figures. Default legend handlers are
defined in the :mod:`~matplotlib.legend_handler` module. While not all artist
types are covered by the default legend handlers, custom legend handlers can be
defined to support arbitrary objects.

See the :doc:`legend guide </tutorials/intermediate/legend_guide>` for more
information.
"""
class DraggableLegend(DraggableOffsetBox):
    def __init__(self, legend, use_blit=..., update=...) -> None:
        """
        Wrapper around a `.Legend` to support mouse dragging.

        Parameters
        ----------
        legend : `.Legend`
            The `.Legend` instance to wrap.
        use_blit : bool, optional
            Use blitting for faster image composition. For details see
            :ref:`func-animation`.
        update : {'loc', 'bbox'}, optional
            If "loc", update the *loc* parameter of the legend upon finalizing.
            If "bbox", update the *bbox_to_anchor* parameter.
        """
        ...
    
    def finalize_offset(self): # -> None:
        ...
    


class Legend(Artist):
    """
    Place a legend on the axes at location loc.
    """
    codes = ...
    zorder = ...
    def __str__(self) -> str:
        ...
    
    @docstring.dedent_interpd
    def __init__(self, parent, handles, labels, loc=..., numpoints=..., markerscale=..., markerfirst=..., scatterpoints=..., scatteryoffsets=..., prop=..., fontsize=..., labelcolor=..., borderpad=..., labelspacing=..., handlelength=..., handleheight=..., handletextpad=..., borderaxespad=..., columnspacing=..., ncol=..., mode=..., fancybox=..., shadow=..., title=..., title_fontsize=..., framealpha=..., edgecolor=..., facecolor=..., bbox_to_anchor=..., bbox_transform=..., frameon=..., handler_map=..., title_fontproperties=...) -> None:
        """
        Parameters
        ----------
        parent : `~matplotlib.axes.Axes` or `.Figure`
            The artist that contains the legend.

        handles : list of `.Artist`
            A list of Artists (lines, patches) to be added to the legend.

        labels : list of str
            A list of labels to show next to the artists. The length of handles
            and labels should be the same. If they are not, they are truncated
            to the smaller of both lengths.

        Other Parameters
        ----------------
        %(_legend_kw_doc)s

        Notes
        -----
        Users can specify any arbitrary location for the legend using the
        *bbox_to_anchor* keyword argument. *bbox_to_anchor* can be a
        `.BboxBase` (or derived there from) or a tuple of 2 or 4 floats.
        See `set_bbox_to_anchor` for more detail.

        The legend location can be specified by setting *loc* with a tuple of
        2 floats, which is interpreted as the lower-left corner of the legend
        in the normalized axes coordinate.
        """
        ...
    
    _loc = ...
    @allow_rasterization
    def draw(self, renderer): # -> None:
        ...
    
    _default_handler_map = ...
    @classmethod
    def get_default_handler_map(cls): # -> dict[Type[StemContainer] | Type[ErrorbarContainer] | Type[Line2D] | Type[Patch] | Type[StepPatch] | Type[LineCollection] | Type[RegularPolyCollection] | Type[CircleCollection] | Type[BarContainer] | Type[tuple[Unknown, ...]] | Type[PathCollection] | Type[PolyCollection], Unknown]:
        """
        A class method that returns the default handler map.
        """
        ...
    
    @classmethod
    def set_default_handler_map(cls, handler_map): # -> None:
        """
        A class method to set the default handler map.
        """
        ...
    
    @classmethod
    def update_default_handler_map(cls, handler_map): # -> None:
        """
        A class method to update the default handler map.
        """
        ...
    
    def get_legend_handler_map(self): # -> dict[Type[StemContainer] | Type[ErrorbarContainer] | Type[Line2D] | Type[Patch] | Type[StepPatch] | Type[LineCollection] | Type[RegularPolyCollection] | Type[CircleCollection] | Type[BarContainer] | Type[tuple[Unknown, ...]] | Type[PathCollection] | Type[PolyCollection], Unknown]:
        """
        Return the handler map.
        """
        ...
    
    @staticmethod
    def get_legend_handler(legend_handler_map, orig_handle): # -> None:
        """
        Return a legend handler from *legend_handler_map* that
        corresponds to *orig_handler*.

        *legend_handler_map* should be a dictionary object (that is
        returned by the get_legend_handler_map method).

        It first checks if the *orig_handle* itself is a key in the
        *legend_handler_map* and return the associated value.
        Otherwise, it checks for each of the classes in its
        method-resolution-order. If no matching key is found, it
        returns ``None``.
        """
        ...
    
    def get_children(self): # -> list[Unknown]:
        ...
    
    def get_frame(self): # -> FancyBboxPatch:
        """Return the `~.patches.Rectangle` used to frame the legend."""
        ...
    
    def get_lines(self): # -> list[Line2D]:
        r"""Return the list of `~.lines.Line2D`\s in the legend."""
        ...
    
    def get_patches(self): # -> silent_list:
        r"""Return the list of `~.patches.Patch`\s in the legend."""
        ...
    
    def get_texts(self): # -> silent_list:
        r"""Return the list of `~.text.Text`\s in the legend."""
        ...
    
    def set_title(self, title, prop=...): # -> None:
        """
        Set the legend title. Fontproperties can be optionally set
        with *prop* parameter.
        """
        ...
    
    def get_title(self): # -> Text:
        """Return the `.Text` instance for the legend title."""
        ...
    
    def get_window_extent(self, renderer=...): # -> Bbox:
        ...
    
    def get_tightbbox(self, renderer): # -> Bbox:
        ...
    
    def get_frame_on(self): # -> bool:
        """Get whether the legend box patch is drawn."""
        ...
    
    def set_frame_on(self, b): # -> None:
        """
        Set whether the legend box patch is drawn.

        Parameters
        ----------
        b : bool
        """
        ...
    
    draw_frame = ...
    def get_bbox_to_anchor(self): # -> TransformedBbox | BboxBase | Bbox:
        """Return the bbox that the legend will be anchored to."""
        ...
    
    def set_bbox_to_anchor(self, bbox, transform=...): # -> None:
        """
        Set the bbox that the legend will be anchored to.

        Parameters
        ----------
        bbox : `~matplotlib.transforms.BboxBase` or tuple
            The bounding box can be specified in the following ways:

            - A `.BboxBase` instance
            - A tuple of ``(left, bottom, width, height)`` in the given
              transform (normalized axes coordinate if None)
            - A tuple of ``(left, bottom)`` where the width and height will be
              assumed to be zero.
            - *None*, to remove the bbox anchoring, and use the parent bbox.

        transform : `~matplotlib.transforms.Transform`, optional
            A transform to apply to the bounding box. If not specified, this
            will use a transform to the bounding box of the parent.
        """
        ...
    
    def contains(self, event): # -> tuple[Literal[False], dict[Unknown, Unknown]] | tuple[bool, dict[Unknown, Unknown]]:
        ...
    
    def set_draggable(self, state, use_blit=..., update=...): # -> DraggableLegend | None:
        """
        Enable or disable mouse dragging support of the legend.

        Parameters
        ----------
        state : bool
            Whether mouse dragging is enabled.
        use_blit : bool, optional
            Use blitting for faster image composition. For details see
            :ref:`func-animation`.
        update : {'loc', 'bbox'}, optional
            The legend parameter to be changed when dragged:

            - 'loc': update the *loc* parameter of the legend
            - 'bbox': update the *bbox_to_anchor* parameter of the legend

        Returns
        -------
        `.DraggableLegend` or *None*
            If *state* is ``True`` this returns the `.DraggableLegend` helper
            instance. Otherwise this returns *None*.
        """
        ...
    
    def get_draggable(self): # -> bool:
        """Return ``True`` if the legend is draggable, ``False`` otherwise."""
        ...
    


